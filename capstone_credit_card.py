# -*- coding: utf-8 -*-
"""Capstone Credit Card.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R0sIlbKmluOy1yLfa__ePGmc7BvuvIX4

# Project Proposal: Credit Card Approval Prediction
Project Overview:
The objective of this project is to develop a predictive model that assesses the creditworthiness of applicants for credit card approval. The model will analyze various features, including demographic information, financial history, and other relevant factors, to predict whether an applicant is likely to be a responsible borrower. The proposed solution aims to enhance the efficiency of the credit approval process, minimize the risk of defaults, and improve the overall decision-making process for credit card issuance.
"""

# Importing libraries
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import OrdinalEncoder
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import GradientBoostingClassifier
from xgboost import XGBClassifier
from sklearn.neighbors import KNeighborsClassifier
from pandas import DataFrame

data = pd.read_csv("Credit_card.csv")
df = pd.DataFrame(data)
df.head()

df.columns

df.dtypes

df.nunique()

"""# Knowing the Data
To understand our data better, we use handy pandas features df.info() and df.describe(). Let’s first print the information of the dataset by using df.info().
"""

df.describe()

"""df.describe() prints the summary statistics of columns with numeric dtype. To ensure the convergence of cost function minimization in machine learning models, all feature variables are scaled using different feature scaling techniques. This is discussed in detail in the analysis section."""

df.info()

"""From the output we get the following information about the data: Data has a total of 1548 entries .Dtype column, we see several features with Dtype as object (string or mixed). Machine learning (ML) algorithms require all feature variables to be of numeric data type. We discuss this issue in detail later in the analysis section. Let’s explore more details of our data using df.describe(). The output is shown above"""

# for each of the categorical columns, lets see the unique values
for i in df.columns:
    #print(i)
    if df[i].dtype==object:
        print(df[i].unique())

"""Checking the percentage of the missing values as the 'Type_occupation' has more 30% data is missing that is column is dropped"""

# check total no.of missing values
df.isnull().sum()/len(df)*100
df=df.drop('Type_Occupation',axis=1)

"""Checking the distribution fo the each of the features by plottting the histograms"""

for col in df:
    plt.figure(figsize=(6, 4))
    sns.histplot(data=df, x=col, kde=True)
    plt.title(f'Distribution of {col}')
    plt.show()

"""# Handling the missing values:
Whether we like it or not, real-world data is messy. Data cleaning is a major part of every data science project and every dataset can possibly have missing values for multiple columns corresponding to a data entry. Before starting to analyze the data and draw conclusions, it is necessary to understand the presence of missing values in our dataset. Missing values in a dataset can be denoted by different conventions (NaN …). For the column with dtype as int/float, missing values are denoted by NaN. For columns with categorical datatypes, we print the unique values. We can see that the dataset has some missing values and they are labeled with ‘NaN’.
"""

def fix_missing_mean(df,col):
    ''' This function takes a data frame as input
    replaces the missing values of a particular column with it's mean value
    '''
    #replace missing values with mean
    df[col] = pd.to_numeric(df[col], errors = 'coerce')
    df[col].fillna(df[col].mean(), inplace = True)

def fix_missing_ffill(df, col):
    ''' This function takes a data frame as input
    replaces the missing values of a particular column with the value from the previous row
    '''
    df[col] = df[col].fillna(method='ffill')

# 0   Ind_ID           1548 non-null   int64
#  1   GENDER           1541 non-null   object
#  2   Car_Owner        1548 non-null   object
#  3   Propert_Owner    1548 non-null   object
#  4   CHILDREN         1548 non-null   int64
#  5   Annual_income    1525 non-null   float64
#  6   Type_Income      1548 non-null   object
#  7   EDUCATION        1548 non-null   object
#  8   Marital_status   1548 non-null   object
#  9   Housing_type     1548 non-null   object
#  10  Birthday_count   1526 non-null   float64
#  11  Employed_days    1548 non-null   int64
#  12  Mobile_phone     1548 non-null   int64
#  13  Work_Phone       1548 non-null   int64
#  14  Phone            1548 non-null   int64
#  15  EMAIL_ID         1548 non-null   int64
#  16  Type_Occupation  1060 non-null   object
#  17  Family_Members   1548 non-null   int64

fix_missing_ffill(df,'Car_Owner')
fix_missing_ffill(df,'GENDER')
fix_missing_ffill(df,'Propert_Owner')
fix_missing_ffill(df,'Type_Income')
fix_missing_ffill(df,'EDUCATION')
fix_missing_ffill(df,'Marital_status')
fix_missing_ffill(df,'Housing_type')


fix_missing_mean(df,'Ind_ID')
fix_missing_mean(df,'CHILDREN')
fix_missing_mean(df,'Annual_income')
fix_missing_mean(df,'Birthday_count')
fix_missing_mean(df,'Employed_days')
fix_missing_mean(df,'Mobile_phone')
fix_missing_mean(df,'Work_Phone')
fix_missing_mean(df,'Phone')
fix_missing_mean(df,'EMAIL_ID')
fix_missing_mean(df,'Family_Members')

"""# Analysis
The task of predicting whether a credit card application will be approved or rejected based on values of feature variables is a supervised machine learning classification task. We need to separate the dataset into features and target variables. Following the popular convention, we call the dataframe with feature variables as X and the one with target variable as y. To implement machine learning algorithms we use the popular python library scikit-learn.
"""

# Separate target from features
data = pd.read_csv('Credit_card_label.csv')
dfa = pd.DataFrame(data)
y = dfa['label']

"""Preprocessing the data
ML algorithms require all input variables to be of numeric type i.e. if the data contains categorical values, then we need to convert them to numerical before applying a machine learning algorithm. In our project, we will be using the ordinal encoding method to transform the categorical feature variables into numeric.
"""

# List of categorical columns
object_cols = ['Car_Owner','GENDER','Propert_Owner','Type_Income','EDUCATION','Marital_status','Housing_type']

# ordinal-encode categorical columns
X = df.copy()
ordinal_encoder = OrdinalEncoder()
X[object_cols] = ordinal_encoder.fit_transform(df[object_cols])

# Preview the ordinal-encoded features
X.head()

xTrain, xTest, yTrain, yTest = train_test_split(X, y,
                                               test_size=0.30,
                                               random_state=2)

"""# Feature Selection

Selecting the proper feature for machine to learn is important here RFE(Recursive Feature elemination ) is used for selecting the proper features among all the features which are there in the dataset
"""

from sklearn.feature_selection import RFE
from sklearn.linear_model import LinearRegression  # Replace with your chosen estimator




# Replace LinearRegression with your chosen estimator
estimator = LinearRegression()

# Number of features to select
num_features_to_select = 5

# Create the RFE model and select features
rfe = RFE(estimator, n_features_to_select=num_features_to_select)
X_rfe = rfe.fit_transform(X, y)

# Print the selected features
selected_features = [f"Feature {i+1}" for i in range(num_features_to_select) if rfe.support_[i]]
print("Selected Features:", selected_features)

X = df[['GENDER','CHILDREN']]

"""# Machine Learning Classifiers
Now we have our dataset ready for building a machine learning-based classifier. There are several classification models that can be used for this task. In this analysis, we will build five different types of classification models namely Logistic Regression, Decision Tree, Gradient Boost, XGBoost and, K-Nearest Neighbors (KNN). These are the most popular models used for solving classification problems. All these models can be conveniently implemented using python’s scikit-learn package except for the XGBoost model, which is implemented using the XGBoost package.

# a) Logistic Regression:

Before implementing logistic regression, we scale the feature variables of our dataset using sklearn’s MinMaxScaler method. We train the Logistic Regression model with standard parameters using the training dataset. The trained model is saved as logreg.
"""

# Import MinMaxScaler
from sklearn.preprocessing import MinMaxScaler
# Instantiate MinMaxScaler and use it to rescale X_train and X_test
scaler = MinMaxScaler(feature_range=(0,1))
rescaledxTrain = scaler.fit_transform(xTrain)
rescaledxTest = scaler.fit_transform(xTest)

# Import LogisticRegression
from sklearn.linear_model import LogisticRegression
# Instantiate a LogisticRegression classifier with default parameter values
logreg = LogisticRegression()

# Fit logreg to the train set
logreg.fit(rescaledxTrain, yTrain)

"""We evaluate the performance of our model using test dataset. We use the metric classification accuracy defined as the fraction of times model prediction matches the value of the target variable. For a detailed evaluation of our model, we look at the confusion matrix. The values in the diagonal of the confusion matrix denote the fraction of correct rejection (first-row first entry) or correct approval (second-row second entry) predictions by our classification model

"""

# Import confusion_matrix
from sklearn.metrics import confusion_matrix
# Use logreg to predict instances from the test set and store it
y_pred = logreg.predict(rescaledxTest)
y_pred1 = logreg.predict(rescaledxTrain)

# Get the accuracy score of logreg model and print it
print("Test: Accuracy = ", logreg.score(rescaledxTest,yTest))
print("Train: Accuracy = ", logreg.score(rescaledxTrain,yTrain))

# Print the confusion matrix of the logreg model
confusion_matrix(yTest,y_pred)

"""# b) Decision Tree

The second model we try for our classification task is the Decision tree model. We have used sklearn’s DecisionTreeClassifier algorithm to build the model. We find the optimized value of hyperparameter max_depth by varying it between 1 and 10 in steps of 1. max_depth value decides the number of times a decision tree is allowed to split. In the plot of Accuracy vs Depth for train and test data, we see for max_depth =4 both train and test accuracy are the same. We choose this value for our model as it avoids a model that is either overfitted or underfittted. The final test accuracy score of our decision tree model is 89%.
"""

train_acc=[]
test_acc=[]
list_score=[]
p=[]

for i in range(1, 10):

    dtc = DecisionTreeClassifier(max_depth = i ,random_state = 0)
    dtc.fit(xTrain, yTrain)

    train_pred = dtc.predict(xTrain)
    #train_acc.append(score(train_pred, yTrain))

    test_pred = dtc.predict(xTest)
    #test_acc.append(score(test_pred, yTest))
    test_acc = accuracy_score(yTest, test_pred)
    train_acc = accuracy_score(yTrain, train_pred)
    print(i,'Train score:',train_acc,'Test score:',test_acc)

    list_score.append([i,accuracy_score(train_pred, yTrain),accuracy_score(test_pred, yTest)])


df2 = DataFrame (list_score,columns=['Depth','Train Accuracy','Test Accuracy'])
plt.plot(df2['Depth'],df2['Test Accuracy'],label='Test Accuracy')
plt.plot(df2['Depth'],df2['Train Accuracy'],label='Train Accuracy')
plt.xlabel('Depth')
plt.ylabel('Accuracy')
plt.legend()

"""# c) XGBoost

The third model we try for our classification task is the XGBoost. We built this model using the XGBClassifier algorithm provided by the XGBoost package. Using the XGBoost model with default values for hyperparameters,
"""

# fit model to training data
model = XGBClassifier()
model.fit(xTrain, yTrain)

train_predict = model.predict(xTrain)
test_predict = model.predict(xTest)

test_acc = accuracy_score(yTest, test_predict)
train_acc = accuracy_score(yTrain, train_predict)
print('Train score:',train_acc,'Test score:',test_acc)

"""d) KNN

The fourthh model we try for our classification task is the K-Nearest Neighbors (KNN). We have built the model using sklearn’s KNeighborsClassifier algorithm. We have optimized the hyperparameter n_neighbors by iterating through a range of values from n=2 to n=20 and comparing the accuracy scores. We select the value n_neighbors=7 as it avoids both overfitting and underfitting . With 10 neighbors, the accuracy score on the test sample is 88%. But as we can see the
graph the boundaries of the graph are crossing each other and its result Ambiguity in Predictions


"""

from sklearn.neighbors import KNeighborsClassifier

train_acc=[]
test_acc=[]
list_score=[]

for i in range(2, 20):
    knn = KNeighborsClassifier(n_neighbors=i)

    knn.fit(xTrain,yTrain)

    train_predict = knn.predict(xTrain)
    test_predict = knn.predict(xTest)

    test_acc = accuracy_score(yTest, test_predict)
    train_acc = accuracy_score(yTrain, train_predict)
    print('Train score:',train_acc,'Test score:',test_acc)
    print(i,'Train score:',train_acc,'Test score:',test_acc)

    list_score.append([i,accuracy_score(train_predict, yTrain),accuracy_score(test_predict, yTest)])


df3 = DataFrame (list_score,columns=['n_neighbors','Train Accuracy','Test Accuracy'])
plt.plot(df3['n_neighbors'],df3['Test Accuracy'],label='Test Accuracy')
plt.plot(df3['n_neighbors'],df3['Train Accuracy'],label='Train Accuracy')
plt.xlabel('n_neighbors')
plt.ylabel('Accuracy')
plt.legend()

"""# **CONCLUSION**

We have tried four different classification models for our credit card approval prediction task. The train and test accuracy of the models is summarized in the Figure below. We have obtained the best test data accuracy (88%) from the Logistic Regression classifier. The small difference in train and test accuracy scores indicates the absence of overfitting and underfitting.

![Screenshot 2023-11-22 141233.png](data:image/png;base64,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)

Q1. Why is your proposal important in today’s world? How predicting a good client is worthy for a bank?

Predicting whether a client is a good credit risk is crucial for banks and financial institutions in today's world for several reasons:

Risk Management:

Identifying good clients helps in managing credit risk effectively. Banks can minimize the likelihood of default and potential losses by approving loans to individuals with a higher probability of repaying.
Financial Stability:

Accurate predictions contribute to the overall financial stability of the bank. By avoiding loans to high-risk clients, banks can maintain a healthier loan portfolio and reduce the likelihood of financial instability.
Profitability:

Approving loans to clients who are likely to repay increases the profitability of the bank. It ensures a steady flow of interest payments and reduces the need for provisions against potential loan defaults.

Q2.How is it going to impact the banking sector?

The implementation of a credit card approval prediction model in the banking sector enhancing efficiency, improving risk management, increasing profitability, and fostering positive relationships with customers. It aligns with the evolving landscape of data-driven decision-making and positions banks for success in a competitive and dynamic industry.

Q3. If any, what is the gap in the knowledge or how your proposed method can be helpful if required in future for any bank in India.

While the proposed credit card approval prediction model offers significant benefits, there are potential gaps and considerations specific to the Indian banking sector that should be addressed for successful implementation:

The success of predictive models heavily relies on the availability and quality of data. In some cases, banks may face challenges related to incomplete or outdated data. Ensuring a robust data collection and cleaning process is essential.

The banking sector in India is subject to specific regulations and compliance standards. The model must comply with local laws, data protection regulations, and other regulatory requirements. Regular updates and monitoring are necessary to ensure ongoing compliance.

Hypothesis :

Logistic regression is the best among all the model
"""

from sklearn.metrics import roc_curve, auc

# Function to plot ROC curve
def plot_roc_curve(y_true, y_scores, model_name):
    fpr, tpr, _ = roc_curve(y_true, y_scores)
    roc_auc = auc(fpr, tpr)

    plt.figure(figsize=(8, 8))
    plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'{model_name} (AUC = {roc_auc:.2f})')
    plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic Curve')
    plt.legend(loc='lower right')
    plt.show()

# Calculate and plot ROC curve for each model
for name, model in models:
    y_scores = model.predict_proba(X_test_scaled)[:, 1]
    plot_roc_curve(y_test, y_scores, name)

"""As we can see in the third graph the AUC 0.83 which indicates a higher AUC indicates better discrimination between positive and negative cases."""

# Import necessary libraries
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import matplotlib.pyplot as plt

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standardize features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# List of models to evaluate
models = [
    ('Logistic Regression', LogisticRegression()),
    ('Decision Tree', DecisionTreeClassifier(random_state=42)),
    ('Random Forest', RandomForestClassifier(random_state=42)),
    ('Gradient Boosting', GradientBoostingClassifier(random_state=42))
]

# Train and evaluate each model
results = {'Model': [], 'Accuracy': []}

for name, model in models:
    model.fit(X_train_scaled, y_train)
    y_pred = model.predict(X_test_scaled)

    accuracy = accuracy_score(y_test, y_pred)
    results['Model'].append(name)
    results['Accuracy'].append(accuracy)

    # Print confusion matrix and classification report for each model
    print(f"\n{40*'='}\n{name}\n{40*'='}")
    print(f"Confusion Matrix:\n{confusion_matrix(y_test, y_pred)}")
    print(f"\nClassification Report:\n{classification_report(y_test, y_pred)}")

# Plotting accuracy for comparison
plt.figure(figsize=(10, 6))
plt.bar(results['Model'], results['Accuracy'], color=['blue', 'green', 'orange', 'red'])
plt.title('Model Accuracy Comparison')
plt.xlabel('Model')
plt.ylabel('Accuracy')
plt.ylim(0, 1)
plt.show()

import duckdb
conn=duckdb.connect()
conn.register('df',df)
conn.register('dfa',dfa)
conn.execute("select * from df ").fetchdf()

# Group the customers based on their income type and find the average of their annual income.
conn.execute("select Type_Income,AVG(Annual_income) from df group by Type_Income").fetchdf()

# Find the female owners of cars and property.
conn.execute("select Car_Owner,Propert_Owner from df where GENDER = 'F' ").fetchdf()

# Find the male customers who are staying with their families.
conn.execute("select * from df where Marital_status = 'Married' and GENDER ='M'").fetchdf()

# Please list the top five people having the highest income.
conn.execute("select Annual_income from df order by Annual_income desc limit 5").fetchdf()

# How many married people are having bad credit?
conn.execute("select * from df where Ind_ID IN(select Ind_ID from dfa where label = '0') and Marital_status='Married'").fetchdf()

# What is the highest education level and what is the total count?
conn.execute("select COUNT(EDUCATION) as Total_count from df where EDUCATION = 'Higher education'").fetchdf()

# Between married males and females, who is having more bad credit?
conn.execute("select COUNT(GENDER) MALE from df where Ind_id IN(select Ind_id from dfa where label = '0') and GENDER='M' and Marital_status='Married'").fetchdf()

conn.execute("select COUNT(GENDER) FEMALE from df where Ind_id IN(select Ind_id from dfa where label = '0') and GENDER='F' and Marital_status='Married'").fetchdf()
# female has more bad credit

